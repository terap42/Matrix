// src/app/admin/mission-management/mission-management.page.ts - Version corrig√©e sans erreurs

import { Component, OnInit, OnDestroy } from '@angular/core';
import { ModalController, AlertController, ToastController, LoadingController } from '@ionic/angular';
import { Subject } from 'rxjs';
import { takeUntil, finalize } from 'rxjs/operators';
import { 
  MissionService, 
  Mission, 
  MissionFilters, 
  MissionListResponse,
  MissionStats 
} from './service/mission.service';

@Component({
  selector: 'app-mission-management',
  templateUrl: './mission-management.page.html',
  styleUrls: ['./mission-management.page.scss'],
  standalone: false,
})
export class MissionManagementPage implements OnInit, OnDestroy {
  
  // Donn√©es des missions - Initialis√©es pour √©viter les warnings
  missions: Mission[] = [];
  filteredMissions: Mission[] = [];
  stats: MissionStats | null = null;
  
  // √âtat de chargement
  loading: boolean = false;
  initialLoading: boolean = true;
  
  // Pagination
  currentPage: number = 1;
  itemsPerPage: number = 10;
  totalItems: number = 0;
  totalPages: number = 0;
  
  // Filtres
  filters: MissionFilters = {
    page: 1,
    limit: 10,
    sortBy: 'created_at',
    sortOrder: 'DESC'
  };
  
  // Options pour les filtres
  categories: string[] = [];
  statusOptions = [
    { value: '', label: 'Tous les statuts' },
    { value: 'open', label: 'Ouvertes' },
    { value: 'in_progress', label: 'En cours' },
    { value: 'completed', label: 'Termin√©es' },
    { value: 'cancelled', label: 'Annul√©es' }
  ];
  
  private destroy$ = new Subject<void>();

  constructor(
    private modalController: ModalController,
    private alertController: AlertController,
    private toastController: ToastController,
    private loadingController: LoadingController,
    private missionService: MissionService
  ) {
    console.log('üöÄ MissionManagementPage initialis√©');
  }

  ngOnInit() {
    console.log('üîÑ Initialisation de la page');
    this.initializePage();
  }

  ngOnDestroy() {
    console.log('üõë Destruction de la page');
    this.destroy$.next();
    this.destroy$.complete();
  }

  // Initialisation compl√®te de la page
  private async initializePage() {
    try {
      // Test de connexion API
      this.missionService.checkConnection()
        .pipe(takeUntil(this.destroy$))
        .subscribe({
          next: () => {
            console.log('‚úÖ API connect√©e, chargement des donn√©es');
            this.loadInitialData();
          },
          error: (error) => {
            console.error('‚ùå Connexion API √©chou√©e:', error);
            this.showErrorToast('Impossible de se connecter au serveur');
            this.initialLoading = false;
          }
        });

      // S'abonner aux mises √† jour
      this.subscribeToUpdates();
      
      // Charger les cat√©gories
      this.loadCategories();
      
    } catch (error) {
      console.error('‚ùå Erreur initialisation:', error);
      this.initialLoading = false;
    }
  }

  // Charger les donn√©es initiales
  private loadInitialData() {
    Promise.all([
      this.loadMissionsPromise(),
      this.loadStatsPromise()
    ]).then(() => {
      this.initialLoading = false;
      console.log('‚úÖ Donn√©es initiales charg√©es');
    }).catch(() => {
      this.initialLoading = false;
    });
  }

  // S'abonner aux mises √† jour en temps r√©el
  private subscribeToUpdates() {
    this.missionService.missionsUpdated$
      .pipe(takeUntil(this.destroy$))
      .subscribe(updated => {
        if (updated) {
          console.log('üîÑ Mise √† jour d√©tect√©e, rechargement...');
          this.loadMissions();
          this.loadStats();
        }
      });
  }

  // Charger les cat√©gories
  private loadCategories() {
    this.missionService.getMissionCategories()
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (categories) => {
          this.categories = categories;
          console.log('‚úÖ Cat√©gories charg√©es:', categories.length);
        },
        error: (error) => {
          console.error('‚ùå Erreur chargement cat√©gories:', error);
        }
      });
  }

  // M√âTHODE CORRIG√âE - Charger les missions depuis l'API
  loadMissions() {
    if (this.loading) return;
    
    this.loading = true;
    console.log('üìã Chargement missions avec filtres:', this.filters);
    
    const requestFilters: MissionFilters = {
      ...this.filters,
      page: this.currentPage,
      limit: this.itemsPerPage
    };

    this.missionService.getMissions(requestFilters)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.loading = false)
      )
      .subscribe({
        next: (response: any) => {
          console.log('üì¶ R√©ponse compl√®te re√ßue:', response);
          
          // V√âRIFICATION ET CORRECTION DE LA STRUCTURE
          if (!response) {
            console.error('‚ùå R√©ponse vide');
            this.missions = [];
            this.filteredMissions = [];
            this.totalItems = 0;
            this.totalPages = 0;
            return;
          }

          // Cas 1: La r√©ponse est directement un tableau de missions
          if (Array.isArray(response)) {
            console.log('üìã R√©ponse = tableau direct');
            this.missions = response;
            this.filteredMissions = response;
            this.totalItems = response.length;
            this.totalPages = Math.ceil(response.length / this.itemsPerPage);
            this.currentPage = 1;
          }
          // Cas 2: La r√©ponse a une structure avec missions
          else if (response.missions) {
            console.log('üìã R√©ponse = objet avec missions');
            this.missions = response.missions;
            this.filteredMissions = response.missions;
            this.totalItems = response.pagination?.totalItems || response.missions.length;
            this.totalPages = response.pagination?.totalPages || Math.ceil(this.totalItems / this.itemsPerPage);
            this.currentPage = response.pagination?.currentPage || 1;
          }
          // Cas 3: La r√©ponse a une structure avec data
          else if (response.data) {
            console.log('üìã R√©ponse = objet avec data');
            this.missions = Array.isArray(response.data) ? response.data : response.data.missions || [];
            this.filteredMissions = this.missions;
            this.totalItems = response.data.total || response.data.pagination?.totalItems || this.missions.length;
            this.totalPages = response.data.pagination?.totalPages || Math.ceil(this.totalItems / this.itemsPerPage);
            this.currentPage = response.data.pagination?.currentPage || 1;
          }
          // Cas 4: Structure inconnue
          else {
            console.error('‚ùå Structure de r√©ponse inconnue:', response);
            this.missions = [];
            this.filteredMissions = [];
            this.totalItems = 0;
            this.totalPages = 0;
          }
          
          console.log(`‚úÖ ${this.missions.length} missions charg√©es, Total: ${this.totalItems}`);
        },
        error: (error) => {
          console.error('‚ùå Erreur chargement missions:', error);
          this.showErrorToast('Erreur lors du chargement des missions');
          
          // R√©initialiser en cas d'erreur
          this.missions = [];
          this.filteredMissions = [];
          this.totalItems = 0;
          this.totalPages = 0;
        }
      });
  }

  // M√âTHODE CORRIG√âE - Version Promise pour le chargement initial
  private loadMissionsPromise(): Promise<void> {
    return new Promise((resolve, reject) => {
      const requestFilters: MissionFilters = {
        ...this.filters,
        page: this.currentPage,
        limit: this.itemsPerPage
      };

      this.missionService.getMissions(requestFilters)
        .pipe(takeUntil(this.destroy$))
        .subscribe({
          next: (response: any) => {
            console.log('üì¶ Promise - R√©ponse re√ßue:', response);
            
            if (!response) {
              this.missions = [];
              this.filteredMissions = [];
              this.totalItems = 0;
              this.totalPages = 0;
              resolve();
              return;
            }

            if (Array.isArray(response)) {
              this.missions = response;
              this.filteredMissions = response;
              this.totalItems = response.length;
              this.totalPages = Math.ceil(response.length / this.itemsPerPage);
              this.currentPage = 1;
            } else if (response.missions) {
              this.missions = response.missions;
              this.filteredMissions = response.missions;
              this.totalItems = response.pagination?.totalItems || response.missions.length;
              this.totalPages = response.pagination?.totalPages || Math.ceil(this.totalItems / this.itemsPerPage);
              this.currentPage = response.pagination?.currentPage || 1;
            } else if (response.data) {
              this.missions = Array.isArray(response.data) ? response.data : response.data.missions || [];
              this.filteredMissions = this.missions;
              this.totalItems = response.data.total || response.data.pagination?.totalItems || this.missions.length;
              this.totalPages = response.data.pagination?.totalPages || Math.ceil(this.totalItems / this.itemsPerPage);
              this.currentPage = response.data.pagination?.currentPage || 1;
            } else {
              this.missions = [];
              this.filteredMissions = [];
              this.totalItems = 0;
              this.totalPages = 0;
            }
            
            resolve();
          },
          error: (error) => {
            console.error('‚ùå Promise - Erreur chargement missions:', error);
            this.missions = [];
            this.filteredMissions = [];
            this.totalItems = 0;
            this.totalPages = 0;
            reject(error);
          }
        });
    });
  }

  // Charger les statistiques
  loadStats() {
    this.missionService.getMissionStats()
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (stats) => {
          this.stats = stats;
          console.log('‚úÖ Statistiques charg√©es:', stats);
        },
        error: (error) => {
          console.error('‚ùå Erreur chargement stats:', error);
        }
      });
  }

  // Version Promise pour le chargement initial
  private loadStatsPromise(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.missionService.getMissionStats()
        .pipe(takeUntil(this.destroy$))
        .subscribe({
          next: (stats) => {
            this.stats = stats;
            resolve();
          },
          error: reject
        });
    });
  }

  // M√âTHODE DE DEBUG CORRIG√âE - Tester directement le service
  debugMissionService() {
    console.log('üîç Test direct du service...');
    
    this.missionService.getMissions({
      page: 1,
      limit: 10,
      sortBy: 'created_at',
      sortOrder: 'DESC'
    }).subscribe({
      next: (response) => {
        console.log('üîç Debug - Type de response:', typeof response);
        console.log('üîç Debug - Response est array:', Array.isArray(response));
        console.log('üîç Debug - Response compl√®te:', response);
        console.log('üîç Debug - Cl√©s de response:', response ? Object.keys(response) : 'undefined');
        
        if (response && typeof response === 'object' && !Array.isArray(response)) {
          // Correction du typage pour √©viter l'erreur TS7053
          const responseObj = response as { [key: string]: any };
          Object.keys(responseObj).forEach(key => {
            console.log(`üîç Debug - ${key}:`, responseObj[key]);
          });
        }
      },
      error: (error) => {
        console.error('üîç Debug - Erreur:', error);
      }
    });
  }

  // M√âTHODE DE TEST CORRIG√âE - Charger des missions de test avec types corrects
  loadTestMissions() {
    console.log('üß™ Chargement de missions de test...');
    
    const testMissions: Mission[] = [
      {
        id: 'test-1',
        title: 'Mission de test 1',
        description: 'Description de test pour la premi√®re mission',
        category: 'D√©veloppement Web',
        clientId: 'client-test-1',
        clientName: 'Client Test',
        clientEmail: 'client.test@example.com',
        budget: 1000,
        currency: 'EUR',
        status: 'open',
        priority: 'medium',
        applicationsCount: 5,
        skillsRequired: ['JavaScript', 'Angular', 'TypeScript'],
        deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // Dans 7 jours
        isReported: false,
        reportReason: '',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      },
      {
        id: 'test-2',
        title: 'Mission de test 2',
        description: 'Autre description de test pour la deuxi√®me mission',
        category: 'Mobile Development',
        clientId: 'client-test-2',
        clientName: 'Autre Client',
        clientEmail: 'autre.client@example.com',
        budget: 2000,
        currency: 'EUR',
        status: 'in_progress',
        priority: 'high',
        applicationsCount: 8,
        skillsRequired: ['TypeScript', 'Ionic', 'Angular'],
        deadline: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(), // Dans 14 jours
        isReported: true,
        reportReason: 'Contenu inappropri√©',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      },
      {
        id: 'test-3',
        title: 'Mission de test 3',
        description: 'Troisi√®me mission de test avec un budget plus √©lev√©',
        category: 'Full Stack',
        clientId: 'client-test-3',
        clientName: 'Super Client',
        clientEmail: 'super.client@example.com',
        budget: 5000,
        currency: 'EUR',
        status: 'completed',
        priority: 'low',
        applicationsCount: 12,
        skillsRequired: ['React', 'Node.js', 'MongoDB', 'AWS'],
        deadline: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(), // Il y a 7 jours
        isReported: false,
        reportReason: '',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    ];

    this.missions = testMissions;
    this.filteredMissions = testMissions;
    this.totalItems = testMissions.length;
    this.totalPages = 1;
    this.currentPage = 1;
    
    console.log('‚úÖ Missions de test charg√©es');
    this.showSuccessToast('Missions de test charg√©es avec succ√®s');
  }

  // Appliquer les filtres
  onFiltersChange(newFilters: any) {
    console.log('üîç Nouveaux filtres appliqu√©s:', newFilters);
    this.filters = { ...this.filters, ...newFilters };
    this.currentPage = 1; // Reset √† la premi√®re page
    this.loadMissions();
  }

  // Recherche textuelle
  onSearchChange(searchTerm: string) {
    console.log('üîç Recherche:', searchTerm);
    this.filters.search = searchTerm || undefined;
    this.currentPage = 1;
    this.loadMissions();
  }

  // Voir les d√©tails d'une mission
  async viewMissionDetail(mission: Mission) {
    console.log('üëÅÔ∏è Affichage d√©tails mission:', mission.id);
    
    const alert = await this.alertController.create({
      header: mission.title,
      message: `
        <div class="mission-detail">
          <p><strong>Description:</strong><br>${mission.description}</p>
          <p><strong>Client:</strong> ${mission.clientName}</p>
          <p><strong>Budget:</strong> ${mission.budget} ${mission.currency}</p>
          <p><strong>Statut:</strong> ${this.missionService.getStatusLabel(mission.status)}</p>
          <p><strong>Candidatures:</strong> ${mission.applicationsCount}</p>
          <p><strong>Comp√©tences:</strong> ${mission.skillsRequired.join(', ')}</p>
          ${mission.deadline ? `<p><strong>√âch√©ance:</strong> ${new Date(mission.deadline).toLocaleDateString()}</p>` : ''}
          ${mission.isReported ? `<p><strong>‚ö†Ô∏è Signal√©e:</strong> ${mission.reportReason}</p>` : ''}
        </div>
      `,
      buttons: ['Fermer'],
      cssClass: 'mission-detail-alert'
    });
    
    await alert.present();
  }

  // Supprimer une mission
  async deleteMission(mission: Mission) {
    console.log('üóëÔ∏è Demande suppression mission:', mission.id);
    
    const alert = await this.alertController.create({
      header: 'Confirmer la suppression',
      message: `√ätes-vous s√ªr de vouloir supprimer la mission "${mission.title}" ?`,
      buttons: [
        {
          text: 'Annuler',
          role: 'cancel'
        },
        {
          text: 'Supprimer',
          handler: () => {
            this.confirmDelete(mission);
          }
        }
      ]
    });

    await alert.present();
  }

  // Confirmer la suppression
  private async confirmDelete(mission: Mission) {
    const loading = await this.loadingController.create({
      message: 'Suppression en cours...'
    });
    await loading.present();

    this.missionService.deleteMission(mission.id)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: () => {
          loading.dismiss();
          this.showSuccessToast(`Mission "${mission.title}" supprim√©e avec succ√®s`);
          this.loadMissions();
          this.loadStats();
        },
        error: (error) => {
          loading.dismiss();
          console.error('‚ùå Erreur suppression:', error);
          this.showErrorToast('Erreur lors de la suppression');
        }
      });
  }

  // Changer le statut d'une mission
  async toggleMissionStatus(mission: Mission) {
    console.log('üîÑ Changement statut mission:', mission.id);
    
    const alert = await this.alertController.create({
      header: 'Changer le statut',
      message: `Choisissez le nouveau statut pour "${mission.title}"`,
      inputs: [
        {
          name: 'status',
          type: 'radio',
          label: 'Ouverte',
          value: 'open',
          checked: mission.status === 'open'
        },
        {
          name: 'status',
          type: 'radio',
          label: 'En cours',
          value: 'in_progress',
          checked: mission.status === 'in_progress'
        },
        {
          name: 'status',
          type: 'radio',
          label: 'Termin√©e',
          value: 'completed',
          checked: mission.status === 'completed'
        },
        {
          name: 'status',
          type: 'radio',
          label: 'Annul√©e',
          value: 'cancelled',
          checked: mission.status === 'cancelled'
        }
      ],
      buttons: [
        {
          text: 'Annuler',
          role: 'cancel'
        },
        {
          text: 'Confirmer',
          handler: (data) => {
            if (data && data !== mission.status) {
              this.updateMissionStatus(mission.id, data);
            }
          }
        }
      ]
    });

    await alert.present();
  }

  // Mettre √† jour le statut
  private updateMissionStatus(missionId: string, status: string) {
    this.missionService.updateMissionStatus(missionId, status)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: () => {
          this.showSuccessToast('Statut mis √† jour avec succ√®s');
          this.loadMissions();
          this.loadStats();
        },
        error: (error) => {
          console.error('‚ùå Erreur changement statut:', error);
          this.showErrorToast('Erreur lors du changement de statut');
        }
      });
  }

  // Navigation pagination
  nextPage() {
    if (this.currentPage < this.totalPages) {
      this.currentPage++;
      this.loadMissions();
    }
  }

  previousPage() {
    if (this.currentPage > 1) {
      this.currentPage--;
      this.loadMissions();
    }
  }

  // Actualiser les donn√©es
  async refreshData() {
    console.log('üîÑ Actualisation des donn√©es');
    this.missionService.refreshData();
  }

  // M√©thodes utilitaires pour l'affichage
  getStatusColor(status: string): string {
    return this.missionService.getStatusColor(status);
  }

  getStatusLabel(status: string): string {
    return this.missionService.getStatusLabel(status);
  }

  getPaginatedMissions(): Mission[] {
    return this.filteredMissions;
  }

  // M√©thode de tracking pour optimiser le rendu
  trackMissionById(index: number, mission: Mission): string {
    return mission?.id || index.toString();
  }

  get endIndex(): number {
    return Math.min(this.currentPage * this.itemsPerPage, this.totalItems);
  }

  get startIndex(): number {
    return this.totalItems > 0 ? (this.currentPage - 1) * this.itemsPerPage + 1 : 0;
  }

  // M√©thodes pour les toasts
  private async showSuccessToast(message: string) {
    const toast = await this.toastController.create({
      message,
      duration: 3000,
      color: 'success',
      position: 'top',
      buttons: [
        {
          text: 'Fermer',
          role: 'cancel'
        }
      ]
    });
    await toast.present();
  }

  private async showErrorToast(message: string) {
    const toast = await this.toastController.create({
      message,
      duration: 5000,
      color: 'danger',
      position: 'top',
      buttons: [
        {
          text: 'Fermer',
          role: 'cancel'
        }
      ]
    });
    await toast.present();
  }
}